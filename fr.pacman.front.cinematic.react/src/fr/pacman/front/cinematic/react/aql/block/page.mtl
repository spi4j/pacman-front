[module page( 	'http://www.obeonetwork.org/dsl/cinematic/3.0.0', 
				'http://www.obeonetwork.org/dsl/cinematic/view/1.0.0', 
				'http://www.obeonetwork.org/dsl/cinematic/flow/1.0.0', 
				'http://www.obeonetwork.org/dsl/cinematic/toolkits/1.0.0',
				'http://www.obeonetwork.org/dsl/environment/3.0.0')/]
				
[import fr::pacman::front::core::aql::name::name /]
[import fr::pacman::front::core::aql::name::directories /]
[import fr::pacman::front::core::aql::query::eobject/]
[import fr::pacman::front::core::aql::query::events/]
[import fr::pacman::front::core::aql::query::metadatas/]
[import fr::pacman::front::cinematic::react::aql::block::widgets/]
[import fr::pacman::front::cinematic::react::aql::query::widgets/]
[import fr::pacman::front::core::aql::query::widgets/]
[import fr::pacman::front::core::service::CinematicUtils/]
[import fr::pacman::front::core::service::AnnotationUtils/]
[import fr::pacman::front::core::aql::output::resources/]

[comment --------------------------------------------------------------------------------]
[comment Pour l'instant on profite du laxisme de typeScript, dans les boucles  on supprime 
         pas la dernière virgule. Ex : ["/goSubMenu2","/goList",].includes(...)
         On prépare le travail sur certains composants mais pour l'instant 1 seul formulaire 
         par page donc 1 seule table éditable donc si table éditable imposibilité de mettre 
         au autre formulaire sur la page. -> géré par la validation du modèle./]
[comment --------------------------------------------------------------------------------]

[comment écriture de la page de service (appelée par la page UI)./]
[template public pageServiceJsxImpl (vc : view::ViewContainer, vs : flow::ViewState )]
[/template]

[comment écriture de la page de service mock (appelée par la page UI)./]
[template public pageMockJsxImpl (vc : view::ViewContainer, vs : flow::ViewState )]
  [vc.writeAdditionalWidgetImports(false)/]
  
  [if (vc.useTables())]
    [for (tb |vc.eAllContents(view::ViewContainer)->select(o | o.isTable()))]
      export function getFakeTableData_[tb.nameElementId()/](nbRows = 10): string['['/][']'/]{
       [protected (('validate form ' + tb.nameElementId()).protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
        
         return Array.from({ length: nbRows }, () => ['['/]
           [for (cl | tb.ownedElements)]
             fakerFR.string.alphanumeric(15),
           [/for]
          [']'/] );
          
       [/protected]
      }
    [/for]
  [/if]
[/template]

[comment aiguillage pour l'écriture d'une page typescript + code jsx (panel)./]				
[template public pageJsxImpl (vc : view::ViewContainer, vs : flow::ViewState )]
  import React from "react";
  import { useEffect, useState } from "react";
  import { useNavigate, useLocation } from "react-router-dom";
  import { useAuth } from "../contexts/AuthContext";
  [if (vc.isHeaderPanel() or vc.isFooterPanel())][vc.pageJsxHFImpl(vs)/][else][vc.pageJsxSDImpl(vs)/][/if]
[/template]

[comment écriture d'une page typescript + code jsx (header-footer panel)./]	
[template public pageJsxHFImpl(vc : view::ViewContainer, vs : flow::ViewState)]
  import { headerFooterDisplayItem } from "@codegouvfr/react-dsfr/Display";
  [if (vc.isHeaderPanel())]
    import { Header } from "@codegouvfr/react-dsfr/Header";
  [else]
    import { Footer } from "@codegouvfr/react-dsfr/Footer";
  [/if]
  [vc.writeElement(false).writePageJsx(vc)/]
[/template]

[comment écriture d'une page typescript + code jsx (standard panel)./]				
[template public pageJsxSDImpl (vc : view::ViewContainer, vs : flow::ViewState )]
  [if (vc.useForm())]
    import { useForm } from "react-hook-form";
    import { Alert } from "@codegouvfr/react-dsfr/Alert";
  [/if]
  [vc.layout.writeLayouts().writePageJsx(vc)/]
[/template]

[comment écriture du corps de la page typescript + code jsx (simple factorisation)./]
[template private writePageJsx(body : String, vc : view::ViewContainer)]
  [vc.writeAdditionalWidgetImports(true)/]
  
  export default function [vc.namePageJsx()/] () {
    
    [if (vc.useSecurity())]
      [vc.writeSecurityHandler()/]
    [/if]
    [if (vc.useForm())]
      [vc.writeFormHandler()/]
    [/if]
    [if (vc.useTables())]
      [vc.writeTablesHandler()/]
    [/if]
    [if (vc.useSearch())]
      [vc.writeSearchHandler()/]
    [/if]
    
    [protected ((vc.nameElementId() + '-custom-code').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    [/protected]
    
    return (
      <>
        [body/]
      </>
    );
  }
[/template]

[comment point d'entrée pour le parcours de layouts. Attention, certain composants 
		 se positionnent par css ,d'autres par js et enfin d'autres ont besoin à 
		 la fois du css et du js./]
[template private writeLayouts(l : view::Layout)]
  [let insideHl = l.isInsideHorizontalLayout()]
    [let allowCSSPos = l.isEligibleForCSSPositioning()]
      [let allowFDSPos = l.isEligibleForFDSPositioning()]
        [l.openLayout(insideHl, allowCSSPos, allowFDSPos)/]
        [l.viewElement.writeElement(insideHl)/]
        [l.scanAllSubLayouts()/]
        [l.closeLayout(insideHl, allowCSSPos, allowFDSPos)/]
      [/let]
    [/let]
  [/let]
[/template]

[comment parcours récursif sur les layouts inclus dans les layouts (sub-layouts)./]
[template private scanAllSubLayouts(l : view::Layout)]
  [if (l <> null)][for (sl : view::Layout | l.eContents())][sl.writeLayouts()/][/for][/if]
[/template]

[comment écriture du code d'ouverture pour un layout./]
[template private openLayout(l : view::Layout, insideHl :: Boolean, allowCssPos :: Boolean,  allowFdsPos :: Boolean)]
  [if (insideHl and allowCssPos)][l.writeOpenHorizontalBloc()/][/if]
  [if (allowFdsPos)][l.writeOpenFormFieldSet()/][/if]
[/template]

[comment écriture du code de fermeture pour un layout./]
[template private closeLayout(l : view::Layout, insideHl :: Boolean, allowCssPos :: Boolean, allowFdsPos :: Boolean)]
  [if (l.isContainer())][l.viewElement.writeCloseViewElement(l.isHorizontalLayoutForJs(insideHl))/][/if]
  [if (allowFdsPos)][l.writeCloseFormFieldSet()/][/if]
  [if (insideHl and allowCssPos)][l.writeCloseHorizontalBloc()/][/if]
[/template]

[comment écriture d'un élement, qu'il s'agisse d'un conteneur ou d'un élément standard./]
[template private writeElement(ve : view::AbstractViewElement, insideHl :: Boolean)]
  [if (ve <> null)]
    [if (ve.hasMetaCustomCode())][ve.writeCustomCode()/][/if]
    [ve.writeOpenViewElement(insideHl)/]
  [/if]
[/template]

[comment écriture d'une zone libre de code pour positionner du code javascript./]
[template private writeCustomCode(ve : view::AbstractViewElement)]
  {/* [protected ((ve.nameElementId() + '-custom-code').protectedId()) startTagPrefix('// ') endTagPrefix('// ')] */}
  [ve.get_metaCustomCode()/]
  {/* [/protected] */}
[/template]
  
[comment écriture pour l'ouverture d'un bloc horizontal./]
[template private writeOpenHorizontalBloc (l : view::Layout)]
  [if (l.isFirstLayoutOfHorizontalContainer())]
    <div className="fr-grid-row fr-grid-row--gutters fr-grid-row--top">
  [/if]
  <div className="fr-col">
[/template]
  
[comment écriture pour la fermeture d'un bloc horizontal./]
[template private writeCloseHorizontalBloc (l : view::Layout)]
  </div>[if (l.isLastLayoutOfHorizontalContainer())]</div>[/if]
[/template] 

[comment écriture de l'ouverture pour un fieldset./]
[template private writeOpenFormFieldSet (l : view::Layout)]
  <div className="fr-fieldset__element">
[/template]

[comment écriture de la fermeture pour un fieldset./]
[template private writeCloseFormFieldSet (l : view::Layout)]
    </div> {/* Close form fieldset */}
[/template]

[comment écriture de la page principale (en dehors de main.tsx qui n'est pas censée changer)./]
[template public pageAppTsxImpl (r : cinematic::CinematicRoot)]
  [let useHF = r.useHFViews()]
    import { useState } from "react";
    import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
    import ProtectedRoutes from "./security/ProtectedRoutes";
    [if (useHF)]
      import { useLocation } from "react-router-dom";
    [/if]
    [for (v : view::ViewContainer  | r.viewPanels())]
      [if (v.isHeaderPanel())]import _Header from "[r.nameDirectoryPagesForAppTsx()/]/[v.namePageJsx()/]";[else]
      [if (v.isFooterPanel())]import _Footer from "[r.nameDirectoryPagesForAppTsx()/]/[v.namePageJsx()/]";
      [else]import [v.namePageJsx()/] from "[r.nameDirectoryPagesForAppTsx()/]/[v.namePageJsx()/]";[/if][/if]
    [/for]
    import reactLogo from "./assets/react.svg";
    import viteLogo from "/vite.svg";
    import "./App.css";
    
    [if (useHF)]
      [r.writeLayouts()/]
    [/if]
    
    function App() {
      return (
        <Router>
          [if (useHF)]<Layout>[/if]
          <Routes>  
            [for (v : view::ViewContainer  | r.viewPanels())]
              [if (not v.isHeaderPanel() and not v.isFooterPanel())]
                [for (rt | v.routesForReact())]
                  [v.writeRoute(rt)/]
                [/for]
              [/if]
            [/for]
          </Routes>
          [if (useHF)]</Layout>[/if]
        </Router>
      );
    }
    export default App
  [/let]
[/template]

[comment écriture de la route pour chaque page (non protégées, protégées, etc...)./]
[template private writeRoute(v : view::ViewContainer, rt :: flow::Transition)]
  [if ('connect'.equalsIgnoreCase(rt.guard))]
    <Route path="/[rt.name/]" element={< [v.namePageJsx()/] />}/>
    // Double l'url pour une url fixe en provenance de AuthContext.tsx
    <Route path="/login" element={< [v.namePageJsx()/] />}/>
  [elseif ('register'.equalsIgnoreCase(rt.guard))]
    <Route element={<ProtectedRoutes />}>
      <Route path="/[rt.name/]" element={< [v.namePageJsx()/] />}/>
    </Route>
  [elseif (rt.guard.index('register:') <> -1)]
    <Route element={<ProtectedRoutes roles={['['/][rt.guard.roles()/][']'/]} />}>
      <Route path="/[rt.name/]" element={< [v.namePageJsx()/] />}/>
    </Route>
  [else]
    <Route path="/[rt.name/]" element={< [v.namePageJsx()/] />}/>
  [/if]
[/template]

[comment écriture de l'encapsulation avec en-tête et pied de page./]
[template private writeLayouts(r : cinematic::CinematicRoot)]
  function Layout({ children }: { children: React.ReactNode }) {
     const location = useLocation();
     const noLayoutRoutes = ['['/]"/fdfs"[']'/]; 
     const hideLayout = noLayoutRoutes.includes(location.pathname);
     return (
     <>
     {!hideLayout && <_Header/>}
        <div className="fr-container form-page"> {children} </div>
     {!hideLayout && <_Footer/>}
     </>
    );
  }
[/template]

[comment écriture de la gestion des tables./]
[template private writeTablesHandler(vc : view::ViewContainer)]
  [let tbs =  vc.eAllContents(view::ViewContainer)->select(o | o.isTable())]
    [for (tb | tbs)]
      const ['['/]data_[tb.nameElementId()/], setData_[tb.nameElementId()/][']'/] = useState<any['['/][']'/]>(['['/][']'/]);
    [/for]
    [if (vc.useTablesEdition())]
      const ['['/]currentRow, setCurrentRow[']'/] = useState<any['['/][']'/] | null>(null);
      const ['['/]currentTable, setCurrentTable[']'/] = useState<[tbs->select(o | o.useButtonEdition())
        ->collect(o1 | '"' + o1.nameElementId() + '"')->sep(' | ')/]| null>(null);
    
      // -----------------------------------------------------
      // Centralisation du pilotage pour la fenêtre d'édition.
      // -----------------------------------------------------
      const handleEditClick = (table: [tbs->select(o | o.useButtonEdition())
        ->collect(o1 | '"' + o1.nameElementId() + '"')->sep(' | ')/], row: any['['/][']'/]) => {
        if (!modal) return;
        setCurrentRow(row);
        setCurrentTable(table);
          [comment on doit obligatoirement avoir un formulaire associé./]
          reset({
            [for (e | vc.eAllContents(view::ViewContainer)
              ->select(o | o.isFormPanel())->first().ownedElements
              ->select(o | o.isEligibleForFormValues()))]
              [e.nameElementId()/]: row['['/][eIndex -1/][']'/],
            [/for]
          });
        setTimeout(() => modal.open(), 0);
      };
        
      // -----------------------------------------------------
      // Centralisation du pilotage pour la fenêtre d'édition.
      // -----------------------------------------------------
      const handleClose = () => {
        if (!modal) return;
        setCurrentRow(null);
        setCurrentTable(null);
        modal.close(); 
      };
    [/if]
    
    // ----------------------------------------------
    // Chargement des tables avec des données de test.
    // ----------------------------------------------
    useEffect(() => {
      [for (tb | tbs)]
        setData_[tb.nameElementId()/](getFakeTableData_[tb.nameElementId()/]());
      [/for]
    }, ['['/][']'/]);
  [/let]
[/template]

[comment écriture de toute la gestion de formulaire./]
[template private writeFormHandler(vc : view::ViewContainer)]
  [let form = vc.form()]
    // --------------------------------------------------
    // Définition du type pour les valeurs du formulaire.
    // --------------------------------------------------
    type FormValues = {
      [for (e | vc.eAllContents(view::AbstractViewElement))]
       [if (e.isEligibleForFormValues())][e.name/] : [e.typeForElement()/];[/if]
      [/for]
    };
    
    // -----------------------------------------------
    // Possibilité de navigation si formulaire valide.
    // -----------------------------------------------
    const navigate = useNavigate();
    
    // ------------------------------------------------------------------------------------
    // Initialise useForm avec le type FormValues pour bénéficier de la validation typée.
    // Récupère register, reset pour lier les champs, handleSubmit pour gérer la soumission,
    // et errors pour afficher les messages d'erreur liés à chaque champ.
    // -----------------------------------------------------------------------------------
    const { 
      reset,
      watch,
      register, 
      handleSubmit, 
      formState: { errors, dirtyFields }, 
    } = useForm<FormValues>({
      mode: "onChange"
    });
    
    // -----------------------------------
    // Etat générique pour message global.    // -----------------------------------  
    const ['['/]globalMessage, setGlobalMessage[']'/] = React.useState<{
      text: string;
      severity: "success" | "error" | "info" | "warning";
    } | null>(null);
    
    // ----------------------------------------------
    // Traitement métier pour la page.
    // -----------------------------------------------
    async function validateAndExecuteForm(data: FormValues): Promise<boolean> {
      console.log("Validation exécutée :", data);
      [protected ('validate form [vc.nameElementId()/]'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
        return true;
      [/protected]
    }
    
    // -----------------------------------------------------
    // Fonction appelée lors de la soumission du formulaire.
    // -----------------------------------------------------
    const onSubmit = async (data: FormValues) => {
      console.log("Formulaire soumis :", data);
      const isValid = await validateAndExecuteForm(data);
      
      if (!isValid) {
        setGlobalMessage({ 
           text: "[form.get_metaTextError()/]", 
           severity: "error",
        });
        //reset(); 
        return;
       }
       
       [comment on doit obligatoirement avoir un formulaire associé./]
       [if (vc.useTablesEdition())]
         // ------------------------------------------------------
         // Gestion des fenêtres modales pour les tables éditables.
         // ------------------------------------------------------
         if (!currentTable || !currentRow) return;
         const updatedRow = ['['/][vc.writeUpdatedRow()/][']'/];
         
         [for (tb | vc.eAllContents(view::ViewContainer)
           ->select(o | o.isTable() and o.useButtonEdition()))]
           if (currentTable === "[tb.nameElementId()/]") {
              setData_[tb.nameElementId()/](prev =>
              prev.map(row => (row['['/]0[']'/] === currentRow['['/]0[']'/] ? updatedRow : row))
              );
           } 
         [/for]
         modal.close();
       [/if]
       
       setGlobalMessage({ 
          text: "[form.get_metaTextSuccess()/]", 
          severity: "success",
       });
       [let onSubmit = vc.eAllContents(view::ViewEvent)->select(e | e.isOnSubmit())]
         [if (not onSubmit->isEmpty())]
           navigate("/[onSubmit->first().get_urlForPageJsx()/]");
         [/if]
       [/let]
    };
    
    // ----------------------------------------------
    // Permet de sécuriser la génération automatique.
    // ----------------------------------------------
    function getRegisterProps(
      fieldName: keyof FormValues,
      rules?: Parameters<typeof register>['['/]1[']'/]) {
      return { ...register(fieldName, rules) };
     }
    
    // ---------------------------------------
    // Centralisation de la gestion des états.
    // ---------------------------------------
    function fieldState(fieldName: keyof FormValues) {
       return errors['['/]fieldName[']'/]
         ? "error"
         : dirtyFields['['/]fieldName[']'/]
         ? "success"
         : "info";
    }
    
    // ----------------------------------------------
    // Centralisation pour l'affichage des messages.
    // ----------------------------------------------
    function fieldMessage(
       fieldName: keyof FormValues,
       defaultMessage: string,
       successMessage: string
     ) {
        return (
         errors['['/]fieldName[']'/]?.message ||
         (dirtyFields['['/]fieldName[']'/] ? successMessage : defaultMessage)
       );
    }
    
    [protected ('custom code form [vc.nameElementId()/]'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    [/protected]
  [/let]
[/template]

[comment écriture de l'injection des données dans la ligne d'édition./]
[template private writeUpdatedRow (vc : view::ViewContainer)]
  [for (e | vc.eAllContents(view::ViewContainer)
       ->select(o | o.isFormPanel())->first().ownedElements
       ->select(o | o.isEligibleForFormValues()))]
        data.[e.nameElementId()/], [/for]
[/template]

[comment écriture des imports pour la page (panel / header / footer / etc..)./]
[template private writeAdditionalWidgetImports(vc : view::ViewContainer, ui : Boolean)]
  [if (ui)]
    [for (ve | vc.get_viewElementForImports()->reject(o | o.isTableEditor()))]
      import { [ve.widget.implementation.trim()/] } from "[ve.reactUriForElement()/]/[ve.widget.implementation.trim()/]";
    [/for]
    [if (vc.useLogos())]
      [let logo = vc.eAllContents(view::AbstractViewElement)
        ->select(e | e.isLogo())->first()]
        import opLogo from "[logo.nameDirectoryImages()/]/[logo.get_metaImg()/]";
      [/let]
    [/if]
    [if (vc.useImages())]
      [for (i | vc.eAllContents(view::AbstractViewElement)
        ->select(e | e.isImage()))]
        import [i.nameElementId()/] from"[i.nameDirectoryImages()/]/[i.get_metaImg()/]";
      [/for]
    [/if]
    [if (vc.useRadiosWithIcon())]
      [for (r | vc.eAllContents(view::AbstractViewElement)
        ->select(e | e.isRadio() and e.has_metaIcon()))]
        import [r.nameElementId()/]Ico from "[r.nameDirectoryImages()/]/[r.get_metaIcon()/]";
      [/for]
    [/if]
    [if (vc.useTables())]
      [let tbls =  vc.eAllContents(view::ViewContainer)->select(o | o.isTable())]
        [for (tb | tbls)]
          import { getFakeTableData_[tb.nameElementId()/] } from "[vc.nameDirectoryPagesMockForAppTsx()/]/[vc.namePageMockJsx()/]";
        [/for]
      [/let]
      [if (vc.useTablesEdition())]
        [vc.writeSpecificModalWidgetImport()/]
      [/if]
    [/if]
  
  [else]
    [if (vc.useTables())]
      import { fakerFR } from '@faker-js/faker';
    [/if]
  [/if]
  [vc.writeProtectedZoneBeforeFunction()/]
[/template]

[comment .écriture de l'import pour la fenêtre modale + initialisation de la fenêtre./]
[template private writeSpecificModalWidgetImport(vc : view::ViewContainer)]
  import { createModal } from "@codegouvfr/react-dsfr/Modal";
  
  // --------------------------------------------------------------------
  // Toujours appeler createModal hors du composant, juste après imports.
  // --------------------------------------------------------------------
  const modal = createModal({ 
     id: "edit-row-modal", 
     isOpenedByDefault: false 
  });
[/template]

[comment écriture du tableau de transformation des données pour les listes déroulantes dans les tables éditables./]
[template private writeProtectedZoneBeforeFunction (vc : view::ViewContainer)]
  [protected ((vc.nameElementId() + '-imports').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    [if (vc.useTables())]
      const selectColumns: Record<number, Record<string, string>> = {
      [if (vc.useSelectInTableEdition() )]
        [for (s | vc.eAllContents(view::ViewContainer)
           ->select(o1 | o1.isTableEditor())
           ->collect(o1 | o1.eAllContents()
           ->select(o2 | o2.isSelect()))
           ->union(Sequence{}))]
            [sIndex/]: {
              [for (option | s.get_metaValues().tokenize(','))]
                [if (option <> null and option.trim().size() > 0  and option.index(':') > 0)]
                     [option.tokenize(':')->at(1)/]:"[option.tokenize(':')->at(2)/]",
                [/if]
              [/for]
            }         
        [/for]
      [/if]
      };
    [/if]
  [/protected]
[/template]

[comment écriture de la gestion générique pour la barre de recherche./]
[template private writeSearchHandler(vc : view::ViewContainer)]
  // -----------------------------------
  // Gestion centralisée de la recherche. 
  // -----------------------------------
  const ['['/]searchTerm, setSearchTerm[']'/] = useState("");
  const navigate = useNavigate();
  const location = useLocation();
  
  const handleSearch = () => {
    if (!searchTerm.trim()) return;
    console.log("Recherche effectuée :", searchTerm);
    navigate(`/[vc.urlForPageJsx()/]?q=${encodeURIComponent(searchTerm)}`);
  };
[/template]

[comment écriture de la gestion générique pour la gestion de la sécurité./]
[template private writeSecurityHandler(vc : view::ViewContainer)]
  // --------------------------------
  // Gestion générique de la sécurité.
  // --------------------------------
  const { login, user, logout } = useAuth();
  
[/template]
