[module widgets(	'http://www.obeonetwork.org/dsl/cinematic/3.0.0', 
					'http://www.obeonetwork.org/dsl/cinematic/view/1.0.0',
					'http://www.obeonetwork.org/dsl/environment/3.0.0', 
					'http://www.obeonetwork.org/dsl/cinematic/flow/1.0.0')/]

[import fr::pacman::front::core::aql::name::name/]
[import fr::pacman::front::core::aql::query::widgets/]
[import fr::pacman::front::core::aql::query::events/]
[import fr::pacman::front::core::aql::query::metadatas/]
[import fr::pacman::front::core::service::CinematicUtils/]
[import fr::pacman::front::core::service::AnnotationUtils/]

[comment retourne l'ensemble des panels./]
[query public viewPanels(r : cinematic::CinematicRoot) : OrderedSet(view::ViewContainer) = r.eAllContents(flow::ViewState)
  ->collect(o1 | o1.viewContainers)->select(o2 | o2.isViewPanel())->asSet()/]
  
[comment vérifie si le container est bien de type panel./]
[query public isViewPanel(vc : view::ViewContainer) : Boolean = vc.isPanel() or vc.isMainPanel() 
  or vc.isModalPanel() or vc.isHeaderPanel() or vc.isFooterPanel()/]

[comment vérifie si la page en cours utilise un formulaire (pour l'instant un seul authorisé par page)./]
[query public useForm(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isFormPanel())->isEmpty()/]

[comment vérifie si la page en cours nécessite l'utilisation de la sécurité./]
[query public useSecurity(vc : view::ViewContainer) : Boolean = true/]
  
[comment vérifie si la page en cours utilise un composant de recherche./]
[query public useSearch(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isSearch())->isEmpty()/]
  
[comment vérifie si la page en cours utilise une (ou plusieurs) table(s)./]
[query public useTables(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isTable())->isEmpty()/]
  
[comment vérifie si la page en cours utilise une (ou plusieurs) table(s) en édition./]
[query public useTablesEdition(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isTable() and o.useButtonEdition())->isEmpty()/]
  
[comment vérifie si la page en cours utilise des tables en édition avec des boites de sélection./]
[query public useSelectInTableEdition(vc : view::ViewContainer) : Boolean = vc.useTablesEdition() 
  and vc.eAllContents(view::ViewContainer)->exists(o1 | o1.isTableEditor() and o1.eAllContents()
  ->exists(o2 | o2.isSelect()))/]
  
[comment ./]
[query public useButtonEdition(vc : view::AbstractViewElement) : Boolean = vc.isTable() and vc.hasMetaTableEdition() 
  and 'true'.equalsIgnoreCase(vc.get_metaTableEdition())/]
  
[comment vérifie si la page en cours utilise une (ou plusieurs) radio(s)./]
[query public useRadiosWithIcon(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isRadio() and o.has_metaIcon())->isEmpty()/]
  
[comment vérifie si la page en cours utilise un (ou plusieurs) logo(s)./]
[query public useLogos(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isLogo())->isEmpty()/]

[comment vérifie si la page en cours utilise une (ou plusieurs) image(s)./]
[query public useImages(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isImage())->isEmpty()/]
  
[comment retourne le formulaire pour la page (si existe)./]
[query public form(vc : view::ViewContainer) : view::AbstractViewElement = vc.eAllContents(view::ViewContainer)
  ->select(e | e.isFormPanel())->first()/]
  
[comment vérifie si l'application utilise un en-tete et/ou un pied de page./]
[query public useHFViews(r :cinematic::CinematicRoot) : Boolean = r.eAllContents(view::AbstractViewElement)
  ->select(o | o.isHeaderPanel() or o.isFooterPanel())->size() = 2/]
  
[comment vérifie si le layout accepte du positionnement css sur l'élément./]
[query public isEligibleForCSSPositioning(l: view::Layout) : Boolean =  l.viewElement = null or (l.viewElement <> null 
  and not l.viewElement.isRadio() and not l.viewElement.isCheckBox() and not l.viewElement.isTableColumn() 
  and not l.viewElement.isTab())/]
  
[comment vérifie si le layout est un conteneur js pour des éléments à positionnement js et non css./]
[query public isEligibleForJSContainer(l: view::Layout) : Boolean = l.viewElement <> null 
  and l.viewElement.isRadioGroup() or l.viewElement.isCheckBoxGroup()/]

[comment vérifie si le layout accepte les balises de positionnement de formulaire./]
[query public isEligibleForFDSPositioning(l: view::Layout) : Boolean =  l.viewElement <> null 
  and l.isInsideFormLayout() and not l.viewElement.isRadio() and not l.viewElement.isCheckBox() and not l.viewElement.isFormPanel() 
  and not l.viewElement.isMainPanel() and not l.viewElement.isPanel() and not l.viewElement.isBlocPanel()/]
  
[comment vérifie si l'élément doit figurer dans les données à faire gérer par hook-form./]
[query  public isEligibleForFormValues(ve : view::AbstractViewElement) : Boolean = ve.isInput() or ve.isPassword() 
  or ve.isRadio() or ve.isCheckBox() or ve.isCombo() or ve.isSelect()/]
  
[comment retourne l'uri react attachée au composant pour les imports./]
[query public reactUriForElement(ve : view::AbstractViewElement) : String = if (ve.isPassword()) then 
  '@codegouvfr/react-dsfr/blocks' else '@codegouvfr/react-dsfr' endif/]
   
[comment vérifie si le layout est à l'intérieur d'un layout horizontal ou si le layout courant est lui même horizontal./]
[query public isHorizontalLayoutForJs(l : view::Layout, insideHL : Boolean) : Boolean = if insideHL 
  and not l.isEligibleForJSContainer() then insideHL else l.isHorizontalLayout() endif /]

[comment retourne le type pour l'élément si l'élément est un conteneur on prend le type du premier élément contenu. Pas 
de vérification sur le contenu, ne devrait pas avoir de null car vérifié auparavant par la validation. On détourne la 
propriété help qui n'est pas visible, si help = true alors c'est un tableau sinon juste le type./]
[query public typeForElement(e : view::AbstractViewElement) : String = if (e.oclIsKindOf(view::ViewElement)) then 
  e.oclAsType(view::ViewElement).type.name.typeJSForElement() else e.oclAsType(view::AbstractViewElement)
  .eAllContents(view::ViewElement)->first().typeForElement() endif + if (e.isCheckBoxGroup()) then '[]' else '' endif/]
  
[comment retourne le transtypage des types pour javascript./]
[query private typeJSForElement(t : String) : String = if ('String'.equalsIgnoreCase(t)) then 'string' 
 else if ('Integer'.equalsIgnoreCase(t)) then 'number' 
 else if ('Float'.equalsIgnoreCase(t)) then 'number' 
 else if ('Double'.equalsIgnoreCase(t)) then 'number' 
 else if ('Long'.equalsIgnoreCase(t)) then 'string'
 else if ('Binary'.equalsIgnoreCase(t)) then 'File' 
 else if ('Boolean'.equalsIgnoreCase(t)) then 'boolean' 
 else if ('Date'.equalsIgnoreCase(t)) then 'string (ISO format "YYYY-MM-DD")' 
 else if ('Time'.equalsIgnoreCase(t)) then 'string (format "HH:mm:ss")' 
 else if ('Timestamp'.equalsIgnoreCase(t)) then 'string (ISO format "YYYY-MM-DDTHH:mm:ss.sssZ")' 
 else 'UNKNOWN TYPE !!' endif endif endif endif endif endif endif endif endif endif/]

[comment retourne l(es)'url(s) pour la page react (utilisé dans le app.tsx pour le routage par react-router)./]
[comment query public routesForReactRouter(v : view::ViewContainer) : Sequence(String) = if(v.isMainPanel()) then Sequence{'/'}
  else v.get_routesForReactRouter()->collect(u | '/' + u) endif/]

[comment retourne l(es)'url(s) pour la page react (utilisé dans le app.tsx pour le routage par react-router)./]
[query public routesForReact(v : view::ViewContainer) : Sequence(flow::Transition) = if(v.isMainPanel()) 
  then Sequence{v.get_routeForMainPanel()} else v.get_routesForReactRouter() endif/]

[comment retourne l'url pour la page (utilisé pour chaque élément qui est un lien)./]
[query public urlForPageJsx(ve : view::AbstractViewElement) : String = let onClick = ve.events
  ->select(e | e.isOnClick())->first() in if onClick <> null then onClick.get_urlForPageJsx() else '#' endif/]

[comment retourne la garde pour la transition associée à l'événement onclick (si existe)./]
[query public useRouteWithGuard(ve : view::AbstractViewElement) : String = let onClick = ve.events
  ->select(e | e.isOnClick())->first() in if onClick <> null then onClick.get_guard() else null endif/]

[comment vérifie si tous les sous-menus sont protégés par une garde./]
[query public useRoutesWithGuard(vc : view::AbstractViewElement) : Boolean = if (not vc.oclIsKindOf(view::ViewContainer)) 
  then false else vc.oclAsType(view::ViewContainer).ownedElements->select(o | o.useRouteWithGuard() <> null)->size() = 
  vc.oclAsType(view::ViewContainer).ownedElements->size() or (vc.hasMetaForceSecured() 
  and 'true'.equalsIgnoreCase(vc.get_metaAllSecured())) endif/]

[comment aggregation des toutes les gardes pour un menu avec sous menus (plus de contrôle on est déjà passé par useRoutesWithGuard)./]
[query public guards(vc : view::AbstractViewElement) : String = '' + vc.oclAsType(view::ViewContainer).ownedElements
  ->select(o | o.useRouteWithGuard() <> null)->collect(o | o.useRouteWithGuard().replaceAll('register:',''))
  ->asSet()->sep(',')/]

[comment construction de la liste des rôles en fonction de ce qui est écrit dans la garde./]
[query public roles(guard : String) : String =  let inner = if guard <> null and guard.index(':') <> -1 
  then guard.substring(guard.index(':') + 1) else '' endif in if inner.size() = 0 then ''
  else '"' + inner.replaceAll('\\s*,\\s*', '", "') + '"' endif/]

