[module widgets(	'http://www.obeonetwork.org/dsl/cinematic/3.0.0', 
					'http://www.obeonetwork.org/dsl/cinematic/view/1.0.0',
					'http://www.obeonetwork.org/dsl/environment/3.0.0', 
					'http://www.obeonetwork.org/dsl/cinematic/flow/1.0.0')/]

[import fr::pacman::front::core::aql::name::name/]
[import fr::pacman::front::core::aql::query::widgets/]
[import fr::pacman::front::core::aql::query::events/]
[import fr::pacman::front::core::service::CinematicUtils/]

[comment retourne l'ensemble des panels./]
[query public viewPanels(r : cinematic::CinematicRoot) : OrderedSet(view::ViewContainer) = r.eAllContents(flow::ViewState)
  ->collect(o1 | o1.viewContainers)->select(o2 | o2.isViewPanel())->asSet()/]
  
[comment vérifie si le container est bien de type panel./]
[query public isViewPanel(vc : view::ViewContainer) : Boolean = vc.isPanel() or vc.isMainPanel() 
  or vc.isModalPanel() or vc.isHeaderPanel() or vc.isFooterPanel()/]

[comment vérifie si la page en cours utilise un formulaire (pour l'instant un seul authorisé par page)./]
[query public useForm(vc : view::ViewContainer) : Boolean = not vc.eAllContents(view::AbstractViewElement)
  ->select(o | o.isFormPanel())->isEmpty()/]

[comment retourne le formulaire pour la page (si existe)./]
[query public form(vc : view::ViewContainer) : view::AbstractViewElement = vc.eContents()
  ->select(e | e.oclIsKindOf(view::AbstractViewElement))->select(e | e.isFormPanel())->first()/]
  
[comment vérifie si l'application utilise un en-tete et/ou un pied de page./]
[query public useHFViews(r :cinematic::CinematicRoot) : Boolean = r.eAllContents(view::AbstractViewElement)
  ->select(o | o.isHeaderPanel() or o.isFooterPanel())->size() = 2/]
  
[comment vérifie si e layout accepte du positionnement css sur l'élément./]
[query public isEligibleForCSSPositioning(l: view::Layout) : Boolean =  l.viewElement = null 
  or (l.viewElement <> null and (not l.viewElement.isRadio() and not l.viewElement.isCheckBox()) 
  and not l.viewElement.isText())/]

[comment vérifie si le layout accepte les balises de positionnement de formulaire./]
[query public isEligibleForFDSPositioning(l: view::Layout) : Boolean =  l.viewElement <> null 
  and l.isInsideFormLayout() and (not l.viewElement.isRadio() and not l.viewElement.isCheckBox() 
  and not l.viewElement.isFormPanel() and not l.viewElement.isMainPanel() and not l.viewElement.isPanel()) 
  and not l.viewElement.isBlocPanel()/]
  
[comment vérifie si l'élément doit figurer dans les données à faire gérer par hook-form./]
[query  public isEligibleForFormValues(ve : view::AbstractViewElement) : Boolean = not ve.isFormPanel() 
 and not ve.isRadio() and not ve.isCheckBox() and not ve.isButton() and not ve.isButtonSubmit() 
 and not ve.isDisplay() and not ve.isTable()/]
  
[comment retourne l'uri react attachée au composant pour les imports./]
[query public reactUriForElement(ve : view::AbstractViewElement) : String = if (ve.isPassword()) then 
  '@codegouvfr/react-dsfr/blocks' else '@codegouvfr/react-dsfr' endif/]
   
[comment vérifie si le layout est à l'intérieur d'un layout horizontal ou si le layout courant est lui même horizontal./]
[query public isHorizontalLayoutForJs(l : view::Layout, insideHL : Boolean) : Boolean = if insideHL then insideHL 
  else l.isHorizontalLayout() endif /]

[comment retourne le type pour l'élément si l'élément est un conteneur on prend le type du premier élément contenu. Pas 
de vérification sur le contenu, ne devrait pas avoir de null car vérifié auparavant par la validation. On détourne la 
propriété help qui n'est pas visible, si help = true alors c'est un tableau sinon juste le type./]
[query public typeForElement(e : view::AbstractViewElement) : String = if (e.oclIsKindOf(view::ViewElement)) then 
  e.oclAsType(view::ViewElement).type.name.typeJSForElement() else e.oclAsType(view::AbstractViewElement)
  .eAllContents(view::ViewElement)->first().typeForElement() endif + if (e.isCheckBoxPanel()) then '[]' else '' endif/]
  
[comment retourne le transtypage des types pour javascript./]
[query private typeJSForElement(t : String) : String = if ('String'.equalsIgnoreCase(t)) then 'string' 
 else if ('Integer'.equalsIgnoreCase(t)) then 'number' 
 else if ('Float'.equalsIgnoreCase(t)) then 'number' 
 else if ('Double'.equalsIgnoreCase(t)) then 'number' 
 else if ('Long'.equalsIgnoreCase(t)) then 'string'
 else if ('Binary'.equalsIgnoreCase(t)) then 'File' 
 else if ('Boolean'.equalsIgnoreCase(t)) then 'boolean' 
 else if ('Date'.equalsIgnoreCase(t)) then 'string (ISO format "YYYY-MM-DD")' 
 else if ('Time'.equalsIgnoreCase(t)) then 'string (format "HH:mm:ss")' 
 else if ('Timestamp'.equalsIgnoreCase(t)) then 'string (ISO format "YYYY-MM-DDTHH:mm:ss.sssZ")' 
 else 'UNKNOWN TYPE !!' endif endif endif endif endif endif endif endif endif endif/]

[comment retourne l(es)'url(s) pour la page react (utilisé dans le app.tsx pour le routage par react-router)./]
[query public urlsForReactRouter(v : view::ViewContainer) : Sequence(String) = if(v.isMainPanel()) then Sequence{'/'}
  else v.get_urlsForReactRouter()->collect(u | '/' + u) endif/]

[comment retourne l'url pour la page (utilisé pour chaque élément qui est un lien)./]
[query public urlForPageJsx(ve : view::AbstractViewElement) : String = let onClick = ve.events
  ->select(e | e.isOnClick())->first() in if onClick <> null then onClick.get_urlForPageJsx() else '#' endif/]

